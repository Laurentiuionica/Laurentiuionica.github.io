Construccion de modelo logico de datos



La construcciÃ³n del **modelo lÃ³gico de datos** es un paso crucial en el diseÃ±o de bases de datos, ya que establece cÃ³mo se organizarÃ¡n y relacionarÃ¡n los datos de forma estructurada y detallada, sin tener en cuenta la implementaciÃ³n fÃ­sica en un sistema de gestiÃ³n de bases de datos (DBMS). El modelo lÃ³gico se basa en el modelo de datos conceptual, pero se ajusta a un nivel mÃ¡s tÃ©cnico, teniendo en cuenta la naturaleza de las relaciones entre los datos y cÃ³mo se almacenarÃ¡n.

### Pasos en la construcciÃ³n del modelo lÃ³gico de datos:

1. **IdentificaciÃ³n de entidades y relaciones**:

   * **Entidades**: Son objetos o conceptos del mundo real que tienen relevancia para el sistema. Por ejemplo, "PelÃ­culas", "Actores", "Productoras" pueden ser entidades en el contexto de una base de datos de cine.
   * **Relaciones**: Representan los vÃ­nculos entre las entidades. Por ejemplo, "Actuar" podrÃ­a ser una relaciÃ³n entre "Actores" y "PelÃ­culas", y "Producir" entre "Productoras" y "PelÃ­culas".

2. **DefiniciÃ³n de atributos**:

   * Cada entidad debe tener atributos que describen sus caracterÃ­sticas. Por ejemplo:

     * **PelÃ­culas**: `nombre`, `aÃ±o`, `gÃ©nero`.
     * **Actores**: `nombre`, `apellido`, `fecha de nacimiento`.
     * **Productoras**: `nombre`, `direcciÃ³n`.
   * Los atributos tambiÃ©n pueden tener tipos de datos, como texto, nÃºmeros, fechas, etc.

3. **DefiniciÃ³n de claves primarias**:

   * Cada entidad debe tener una **clave primaria** que la identifique de manera Ãºnica en la base de datos. Por ejemplo:

     * **PelÃ­culas**: `id_pelicula` (clave primaria).
     * **Actores**: `id_actor` (clave primaria).
     * **Productoras**: `id_productora` (clave primaria).

4. **Establecimiento de las relaciones entre entidades**:

   * **Relaciones de uno a muchos (1\:N)**: Un registro en una entidad se puede asociar con muchos registros en otra entidad. Por ejemplo, una **Productora** puede producir muchas **PelÃ­culas**, pero cada **PelÃ­cula** es producida por una sola **Productora**.
   * **Relaciones de muchos a muchos (N\:M)**: Muchos registros en una entidad pueden estar relacionados con muchos registros en otra. Por ejemplo, un **Actor** puede actuar en muchas **PelÃ­culas** y una **PelÃ­cula** puede tener muchos **Actores**. Para representar estas relaciones, a menudo se utiliza una tabla intermedia, que contiene claves forÃ¡neas de ambas entidades.
   * **Relaciones de uno a uno (1:1)**: Un registro en una entidad se asocia con solo un registro en otra entidad. Estas relaciones no son tan comunes en bases de datos relacionales, pero pueden existir.

5. **NormalizaciÃ³n**:

   * La **normalizaciÃ³n** es el proceso de organizar los datos para evitar redundancias y dependencias. Se busca que cada pieza de informaciÃ³n se almacene en su lugar mÃ¡s adecuado.
   * El proceso implica dividir las tablas para asegurarse de que cada tabla represente solo una entidad o relaciÃ³n y que los datos se almacenen de manera eficiente.

6. **DeterminaciÃ³n de las claves forÃ¡neas**:

   * Las **claves forÃ¡neas** son campos en una entidad que se refieren a la clave primaria de otra entidad. Esto ayuda a establecer las relaciones entre las tablas. Por ejemplo:

     * La entidad **PelÃ­culas** puede tener un campo `id_productora` que sea una **clave forÃ¡nea** que haga referencia a la clave primaria `id_productora` de la entidad **Productoras**.
     * La entidad intermedia entre **Actores** y **PelÃ­culas** puede tener `id_actor` y `id_pelicula` como claves forÃ¡neas.

7. **EspecificaciÃ³n de integridad referencial**:

   * La **integridad referencial** asegura que las relaciones entre las tablas sean consistentes. Por ejemplo, si un actor estÃ¡ asignado a una pelÃ­cula, no deberÃ­a ser posible eliminar al actor sin antes verificar que la relaciÃ³n con la pelÃ­cula tambiÃ©n sea eliminada o modificada.

### Ejemplo de modelo lÃ³gico de datos:

Imagina que estamos creando el modelo lÃ³gico para el sistema de pelÃ­culas que mencionaste:

1. **Entidades**:

   * **PelÃ­culas**: `id_pelicula`, `nombre`, `aÃ±o`, `gÃ©nero`, `id_productora`.
   * **Actores**: `id_actor`, `nombre`, `apellido`.
   * **Productoras**: `id_productora`, `nombre`, `direcciÃ³n`.

2. **Relaciones**:

   * **Actuar** (relaciÃ³n N\:M entre Actores y PelÃ­culas):

     * Tabla intermedia: `Actores_Peliculas` con `id_actor` (clave forÃ¡nea de Actores) y `id_pelicula` (clave forÃ¡nea de PelÃ­culas).
   * **Producir** (relaciÃ³n 1\:N entre Productoras y PelÃ­culas):

     * **PelÃ­culas** tiene una clave forÃ¡nea `id_productora` que hace referencia a **Productoras**.

3. **Esquema de tablas**:

   | **PelÃ­culas**        |   | **Actores**     |   | **Productoras**      |
   | -------------------- | - | --------------- | - | -------------------- |
   | `id_pelicula` (PK)   |   | `id_actor` (PK) |   | `id_productora` (PK) |
   | `nombre`             |   | `nombre`        |   | `nombre`             |
   | `aÃ±o`                |   | `apellido`      |   | `direcciÃ³n`          |
   | `gÃ©nero`             |   |                 |   |                      |
   | `id_productora` (FK) |   |                 |   |                      |

   | **Actores\_Peliculas** |
   | ---------------------- |
   | `id_actor` (FK)        |
   | `id_pelicula` (FK)     |

### Consideraciones adicionales:

* **OptimizaciÃ³n de consultas**: El modelo lÃ³gico debe ser diseÃ±ado de manera que permita realizar consultas eficientes. Esto puede incluir el uso de Ã­ndices en campos clave, como las claves primarias y forÃ¡neas.
* **Seguridad y control de acceso**: Asegurarse de que el modelo cumpla con los requisitos de seguridad de la base de datos.

El modelo lÃ³gico es la base sobre la que luego se crea el modelo fÃ­sico de la base de datos, donde se definen aspectos especÃ­ficos de implementaciÃ³n, como los tipos de almacenamiento, Ã­ndices, particiones, etc.


La **definiciÃ³n de columnas** es una parte fundamental de la construcciÃ³n de un modelo lÃ³gico de datos. Cada columna en una tabla representa un atributo de una entidad o una relaciÃ³n y debe ser definida de manera precisa para que los datos sean almacenados de forma eficiente y consistente. A continuaciÃ³n te explico los elementos clave que deben considerarse al definir las columnas de una tabla:

### Elementos clave en la **definiciÃ³n de columnas**:

1. **Nombre de la columna**:

   * Cada columna debe tener un nombre Ãºnico que describa de forma clara el tipo de dato que contendrÃ¡. Por ejemplo:

     * En la tabla **PelÃ­culas**, una columna puede llamarse `nombre` para almacenar el tÃ­tulo de la pelÃ­cula, o `aÃ±o` para almacenar el aÃ±o de estreno.

2. **Tipo de dato**:

   * El tipo de dato define quÃ© tipo de valor puede contener una columna. Los tipos de datos comunes incluyen:

     * **VARCHAR** o **TEXT**: Para texto o cadenas de caracteres. Por ejemplo, `nombre` podrÃ­a ser de tipo `VARCHAR(255)`.
     * **INT** o **INTEGER**: Para nÃºmeros enteros. Por ejemplo, `aÃ±o` podrÃ­a ser de tipo `INT`.
     * **DATE** o **DATETIME**: Para fechas. Por ejemplo, si tuvieras una columna para la fecha de lanzamiento de una pelÃ­cula, el tipo serÃ­a `DATE`.
     * **DECIMAL** o **FLOAT**: Para valores numÃ©ricos con decimales. Por ejemplo, una columna para el presupuesto de una pelÃ­cula.
     * **BOOLEAN**: Para valores lÃ³gicos (verdadero o falso).

   Es fundamental elegir el tipo de dato adecuado para cada columna, ya que influirÃ¡ en la eficiencia del almacenamiento y las operaciones de consulta.

3. **Restricciones**:

   Las restricciones definen las reglas que deben cumplirse para los valores de las columnas. Algunas de las restricciones mÃ¡s comunes son:

* **NOT NULL**: Asegura que la columna no pueda tener valores nulos.
* **UNIQUE**: Garantiza que todos los valores de la columna sean Ãºnicos.
* **PRIMARY KEY**: Define una columna o combinaciÃ³n de columnas como la clave primaria, Ãºnica y no nula.
* **FOREIGN KEY**: Establece una relaciÃ³n entre tablas, haciendo referencia a la clave primaria de otra tabla.
* **CHECK**: Asegura que los valores de la columna cumplan con ciertas condiciones (por ejemplo, edad >= 18).
* **DEFAULT**: Define un valor predeterminado para una columna cuando no se proporciona un valor al insertar un registro.
* **BINARY**: Se usa para almacenar datos binarios (como imÃ¡genes o contraseÃ±as) en formato binario.
* **UNSIGNED**: Se utiliza en columnas numÃ©ricas para asegurar que los valores sean siempre positivos o cero (no negativos).
* **Zero Filled (ZF)**: Si el campo es numÃ©rico, rellena con ceros a la izquierda para completar hasta su longitud mÃ¡xima. Se usa para asegurar un formato fijo en campos numÃ©ricos.
* **Auto Increment (AI)**: Si el campo es numÃ©rico, incrementa su valor automÃ¡ticamente en uno con cada nuevo registro, ideal para generar identificadores Ãºnicos secuenciales.
* **Generated Column (G)**: Permite crear columnas basadas en el cÃ¡lculo de otras columnas. Puede ser `stored` (almacenado) o `virtual` (calculado sin almacenarlo).

Estas restricciones y caracterÃ­sticas permiten un control mÃ¡s preciso sobre los datos y su formato en la base de datos, asegurando integridad, eficiencia y consistencia en el almacenamiento y manejo de la informaciÃ³n.


Estas restricciones ayudan a garantizar la integridad de los datos, optimizar el rendimiento y asegurar que los valores en las columnas sean consistentes con los requisitos del sistema.


4. **Valor predeterminado (DEFAULT)**:

   * Algunas columnas pueden tener un valor predeterminado. Esto significa que, si no se proporciona un valor explÃ­cito al insertar un registro, se usarÃ¡ este valor predeterminado. Por ejemplo:

     * Si una columna `estado` tiene el valor predeterminado `activo`, entonces, si no se especifica un valor para `estado`, se asignarÃ¡ `activo` automÃ¡ticamente.

5. **Comentarios**:

   * Aunque no es estrictamente necesario, es Ãºtil agregar comentarios en las columnas para documentar su propÃ³sito, especialmente en bases de datos mÃ¡s grandes o complejas. Esto facilita la comprensiÃ³n del diseÃ±o de la base de datos tanto para el equipo de desarrollo como para otros usuarios.

6. **Longitud o precisiÃ³n**:

   * Algunas columnas requieren que se defina su longitud o precisiÃ³n, dependiendo del tipo de dato:

     * En columnas de tipo **VARCHAR**, debes especificar la longitud mÃ¡xima de la cadena. Ejemplo: `nombre VARCHAR(255)` indica que el campo `nombre` puede almacenar cadenas de texto de hasta 255 caracteres.
     * En columnas de tipo **DECIMAL**, debes definir la precisiÃ³n y escala (nÃºmero total de dÃ­gitos y nÃºmero de dÃ­gitos despuÃ©s del punto decimal). Ejemplo: `presupuesto DECIMAL(10,2)` permite almacenar nÃºmeros con hasta 10 dÃ­gitos, de los cuales 2 serÃ¡n decimales.

7. **Ãndices**:

   * Los Ã­ndices pueden definirse sobre ciertas columnas para mejorar el rendimiento de las consultas. Por ejemplo, si haces muchas bÃºsquedas por el nombre de la pelÃ­cula, puede ser Ãºtil crear un Ã­ndice sobre la columna `nombre` en la tabla **PelÃ­culas**.

### Ejemplo de definiciÃ³n de columnas en un modelo lÃ³gico:

**Tabla: PelÃ­culas**

| Columna         | Tipo de Dato | Restricciones             | DescripciÃ³n                               |
| --------------- | ------------ | ------------------------- | ----------------------------------------- |
| `id_pelicula`   | INT          | PRIMARY KEY, NOT NULL     | Identificador Ãºnico para la pelÃ­cula      |
| `nombre`        | VARCHAR(255) | NOT NULL                  | Nombre de la pelÃ­cula                     |
| `aÃ±o`           | INT          | NOT NULL                  | AÃ±o de estreno de la pelÃ­cula             |
| `gÃ©nero`        | VARCHAR(100) |                           | GÃ©nero de la pelÃ­cula                     |
| `id_productora` | INT          | FOREIGN KEY (Productoras) | Referencia a la productora que la produjo |

**Tabla: Actores**

| Columna            | Tipo de Dato | Restricciones         | DescripciÃ³n                       |
| ------------------ | ------------ | --------------------- | --------------------------------- |
| `id_actor`         | INT          | PRIMARY KEY, NOT NULL | Identificador Ãºnico para el actor |
| `nombre`           | VARCHAR(100) | NOT NULL              | Nombre del actor                  |
| `apellido`         | VARCHAR(100) | NOT NULL              | Apellido del actor                |
| `fecha_nacimiento` | DATE         |                       | Fecha de nacimiento del actor     |

**Tabla: Actores\_Peliculas** (RelaciÃ³n N\:M entre Actores y PelÃ­culas)

| Columna       | Tipo de Dato | Restricciones           | DescripciÃ³n              |
| ------------- | ------------ | ----------------------- | ------------------------ |
| `id_actor`    | INT          | FOREIGN KEY (Actores)   | Referencia al actor      |
| `id_pelicula` | INT          | FOREIGN KEY (PelÃ­culas) | Referencia a la pelÃ­cula |

### ConclusiÃ³n:

La definiciÃ³n de columnas es esencial para garantizar que los datos se almacenen correctamente y de manera eficiente. Al definirlas, asegÃºrate de elegir los tipos de datos adecuados, aplicar restricciones apropiadas y documentar el propÃ³sito de cada columna para facilitar el mantenimiento y el uso de la base de datos.





#### 1. **ConversiÃ³n a formas normales**:

* **DefiniciÃ³n**: La normalizaciÃ³n se refiere al proceso de organizar los datos de manera eficiente y sin redundancias.
* **Objetivo**: Aplicar **formas normales** a las tablas para evitar problemas de duplicaciÃ³n y mantener la integridad de los datos.
* **Forma normal N**: Si todas las tablas de la base de datos estÃ¡n en la forma normal N, se considera que la base de datos estÃ¡ en la **forma normal N**.

#### 2. **Ejemplo de tabla no normalizada**:

* La tabla muestra un ejemplo de usuarios con columnas de **NOMBRE**, **CLAVE**, **EMPRESA** y **DIRECCIÃ“N**. A continuaciÃ³n, te muestro cÃ³mo estÃ¡ estructurada la tabla segÃºn la imagen:

| **USUARIOS** |           |             |                   |
| ------------ | --------- | ----------- | ----------------- |
| **NOMBRE**   | **CLAVE** | **EMPRESA** | **DIRECCIÃ“N**     |
| Juan         | Abc2015   | ABC         | C/ Buenventura    |
| Pedro        | Abc2015   | ABC         | C/ Buenventura    |
| Juan         | Juan2015  | XYZ         | C/ Divina Comedia |
| Susana       | Nyork2015 | XYZ         | C/ El Quijote     |

#### 3. **ExplicaciÃ³n**:

* **Redundancia**: Observa que los datos estÃ¡n repetidos:

  * **Juan** aparece dos veces con diferentes direcciones y claves, pero la empresa **ABC** y la direcciÃ³n **C/ Buenaventura** se repiten.
  * **Pedro** tambiÃ©n tiene la misma empresa y direcciÃ³n que Juan, pero con su propia clave.
  * Esta repeticiÃ³n puede generar problemas a largo plazo, como dificultad para actualizar datos si se cambian direcciones o empresas.

### **ConclusiÃ³n**:

Este tipo de tablas no normalizadas es propenso a la **duplicaciÃ³n de datos**, lo cual se resuelve aplicando las formas normales (1NF, 2NF, 3NF, etc.). Al normalizar los datos, se eliminan las redundancias, lo que facilita la actualizaciÃ³n y mantiene la integridad de la base de datos.




---

### **Primera Forma Normal (1FN)** ğŸ§‘â€ğŸ’»ğŸ“Š

**Objetivo**: Evitar **duplicaciÃ³n** de datos y asegurar que cada columna contenga **valores Ãºnicos e indivisibles**. Â¡Todo debe estar bien organizado! âœ¨

#### **Â¿QuÃ© hacer?** ğŸ¤”

1. **Eliminar grupos repetitivos** âŒ:
   Si tenemos columnas que se repiten (como "Coche1", "Coche2"), debemos **crear una tabla separada** para esos datos repetidos y vincularla a la tabla principal. Esto mejora la eficiencia y reduce la redundancia.

2. **Crear una tabla separada por cada grupo relacionado** ğŸ› ï¸:
   Los datos relacionados deben estar en su propia tabla. Por ejemplo, si una persona tiene varios coches, no agregamos mÃºltiples columnas de coche. Creamos una tabla llamada **"Coches"** con el **ID de la persona** (relaciÃ³n) y su **matrÃ­cula** ğŸš—.

#### **Ejemplo:**

* Tabla **Usuarios**:

  | NOMBRE | CLAVE | EMPRESA | DIRECCIÃ“N      |
  | ------ | ----- | ------- | -------------- |
  | Juan   | Abc15 | ABC     | C/ Buenventura |

* **Â¿Y si Juan tiene 2 coches?**
  En lugar de agregar columnas como "Coche1" y "Coche2", creamos una **tabla nueva** de **Coches**:

  | NIF   | MATRÃCULA |
  | ----- | --------- |
  | Abc15 | 123ABC    |
  | Abc15 | 456DEF    |

---

**Resumen:** Para la **Primera Forma Normal (1FN)**, creamos nuevas tablas para evitar la repeticiÃ³n de datos y mantenemos los valores atÃ³micos (sin divisiones innecesarias). Â¡Esto hace que tu base de datos sea mÃ¡s limpia y fÃ¡cil de manejar! âœ¨

---




### **Segunda Forma Normal (2FN) ğŸ“ŠğŸ¯**

#### **Â¿QuÃ© es la Segunda Forma Normal (2FN)?**

La **Segunda Forma Normal (2FN)** se centra en **eliminar dependencias parciales** en las tablas con **clave primaria compuesta**. Esto significa que **todas las columnas no clave** deben depender **totalmente** de la clave primaria completa (y no solo de una parte de ella). ğŸ”„

---

### **Â¿Por quÃ© es importante la 2FN?** ğŸ¤”

* **EliminaciÃ³n de dependencias parciales**: Si una columna depende solo de una parte de la clave primaria, estÃ¡ violando la **2FN**.
* **OptimizaciÃ³n de la base de datos**: La base de datos se vuelve mÃ¡s eficiente y sin redundancias.
* **Integridad de los datos**: Se garantiza que los datos no se repitan innecesariamente, y es mÃ¡s fÃ¡cil hacer actualizaciones.

---

### **Â¿CÃ³mo se aplica la 2FN?** ğŸ› ï¸

1. **Identificar las dependencias parciales**:
   Si tienes una **clave primaria compuesta** (es decir, la clave primaria se forma con mÃ¡s de una columna), algunas columnas pueden depender solo de una parte de esa clave. Esto debe corregirse moviendo esas columnas a otras tablas.

2. **Dividir las tablas correctamente**:
   Se deben crear nuevas tablas para almacenar los datos que dependen solo de una parte de la clave primaria. AsÃ­, cada columna estarÃ¡ completamente relacionada con la clave primaria de su tabla.

---

### **Ejemplo: Tabla sin normalizar (violando 2FN) ğŸ˜¬**

Imagina que tienes una tabla de **Eventos**, donde la clave primaria es una **combinaciÃ³n de `Curso` y `Fecha`**.

| **Curso** | **Fecha** | **CourseTitle**  | **Room** | **Capacity** | **Available** |
| --------- | --------- | ---------------- | -------- | ------------ | ------------- |
| SQL101    | 3/1/2013  | SQL Fundamentals | 4A       | 12           | 4             |
| DB202     | 3/1/2013  | Database Design  | 7B       | 14           | 7             |
| SQL101    | 4/14/2013 | SQL Fundamentals | 7B       | 14           | 10            |
| SQL101    | 5/28/2013 | SQL Fundamentals | 12A      | 8            | 8             |
| CS200     | 4/15/2012 | C Programming    | 4A       | 12           | 11            |

#### **Problema:**

* **`CourseTitle`** depende solo de **`Curso`** y no de **`Fecha`**.
* **`Room`**, **`Capacity`**, y **`Available`** dependen de **`Curso`** y **`Fecha`** juntos.
* La tabla no estÃ¡ en **2FN** porque algunas columnas dependen solo de una parte de la clave primaria.

---

### **SoluciÃ³n con 2FN** âœ‚ï¸

Vamos a separar la tabla en dos para eliminar las dependencias parciales:

1. **Tabla de Cursos** (con clave primaria `Curso`):

| **IDCurso** | **Titulo**       |
| ----------- | ---------------- |
| SQL101      | SQL Fundamentals |
| DB202       | Database Design  |
| CS200       | C Programming    |

2. **Tabla de Eventos** (con clave primaria compuesta `Curso` y `Fecha`):

| **Curso** | **Fecha** | **Room** | **Capacity** | **Available** |
| --------- | --------- | -------- | ------------ | ------------- |
| SQL101    | 3/1/2013  | 4A       | 12           | 4             |
| DB202     | 3/1/2013  | 7B       | 14           | 7             |
| SQL101    | 4/14/2013 | 7B       | 14           | 10            |
| SQL101    | 5/28/2013 | 12A      | 8            | 8             |
| CS200     | 4/15/2012 | 4A       | 12           | 11            |

---

### **Â¿QuÃ© hemos logrado?** ğŸ†

* **Eliminamos la redundancia**: El **`CourseTitle`** se guarda solo una vez en la tabla de **Cursos**, lo que reduce la repeticiÃ³n de datos.
* **Mejoramos la integridad**: Si cambiamos el **nombre del curso**, solo lo necesitamos actualizar en la tabla de **Cursos**, no en todas las filas de la tabla de **Eventos**.
* **Estructura mÃ¡s limpia y eficiente**: Ahora, las tablas estÃ¡n mejor organizadas y cumplen con la **2FN**.

---

### **Resumen final de la 2FN con emojis ğŸ”‘**:

* La **Segunda Forma Normal (2FN)** asegura que **todas las columnas no clave** dependan **completamente** de la **clave primaria completa** (y no de una parte de ella).
* Si tienes una **clave primaria compuesta**, las columnas que dependen solo de una parte de ella deben moverse a una nueva tabla.
* Esto mejora la **estructura de la base de datos**, **reduce redundancias**, y **mejora la integridad de los datos**.

---






### **Tercera Forma Normal (3FN) ğŸ“Š**

#### **Â¿QuÃ© es la Tercera Forma Normal (3FN)?** ğŸ¤”

La **3FN** va mÃ¡s allÃ¡ de la **2FN**. El objetivo es eliminar **dependencias transitivas**. Esto significa que si una columna depende de otra columna que no es la clave primaria, debe ser movida a una tabla separada. ğŸ› ï¸

#### **Â¿QuÃ© hacer en 3FN?** ğŸ”§

Si una columna depende de otra columna **no clave** que, a su vez, depende de la **clave primaria**, entonces esa columna **no cumple con la 3FN**. Para corregirlo, debemos dividir las tablas para que las columnas solo dependan de la clave primaria.

---

### **Ejemplo de 3FN**:

Imagina que tenemos una tabla de **Pedidos** con una clave primaria **`ID_Pedido`**.

| **ID\_Pedido** | **Nombre Cliente** | **DirecciÃ³n Cliente** | **CÃ³digo Postal** | **Fecha Pedido** |
| -------------- | ------------------ | --------------------- | ----------------- | ---------------- |
| 001            | Juan               | Calle Falsa 123       | 28001             | 3/1/2013         |
| 002            | Pedro              | Av. Libertad 45       | 28002             | 4/1/2013         |

#### **Problema:**

* **`CÃ³digo Postal`** depende de **`DirecciÃ³n Cliente`** (ya que el cÃ³digo postal estÃ¡ relacionado con la direcciÃ³n), pero **`DirecciÃ³n Cliente`** depende de **`ID_Pedido`**. Esta es una **dependencia transitiva** que **no cumple con la 3FN**.

#### **SoluciÃ³n en 3FN:**

Crearemos una nueva tabla para los cÃ³digos postales, y **`DirecciÃ³n Cliente`** y **`CÃ³digo Postal`** estarÃ¡n ahora separados:

1. **Tabla de Pedidos**:

   | **ID\_Pedido** | **Nombre Cliente** | **Fecha Pedido** |
   | -------------- | ------------------ | ---------------- |
   | 001            | Juan               | 3/1/2013         |
   | 002            | Pedro              | 4/1/2013         |

2. **Tabla de Direcciones**:

   | **DirecciÃ³n Cliente** | **CÃ³digo Postal** |
   | --------------------- | ----------------- |
   | Calle Falsa 123       | 28001             |
   | Av. Libertad 45       | 28002             |

---

#### **Â¿QuÃ© conseguimos?** ğŸ†

* **Eliminamos dependencias transitivas**: Ahora, el **`CÃ³digo Postal`** depende solo de **`DirecciÃ³n Cliente`** en la tabla **Direcciones**, y no de la **clave primaria** de **Pedidos**.
* **Mejoramos la estructura**: La base de datos estÃ¡ mÃ¡s organizada y mantiene la integridad de los datos sin redundancias.

---



### **Cuarta Forma Normal (4FN) ğŸ“Š**

#### **Â¿QuÃ© es la Cuarta Forma Normal (4FN)?** ğŸ¤”

La **4FN** se centra en la **eliminaciÃ³n de dependencias multivaluadas**. Esto sucede cuando una columna tiene mÃ¡s de un valor independiente que no estÃ¡ relacionado con otras columnas. Es decir, cada atributo debe ser independiente de los demÃ¡s.

#### **Â¿QuÃ© hacer en 4FN?** ğŸ”§

Si una tabla tiene dos o mÃ¡s grupos de datos independientes, cada uno debe estar en su propia tabla para cumplir con la 4FN.

---

### **Ejemplo de 4FN**:

Imagina una tabla de **Productos** que contiene informaciÃ³n sobre los colores y tamaÃ±os disponibles:

| **ID\_Producto** | **Colores Disponibles** | **TamaÃ±os Disponibles** |
| ---------------- | ----------------------- | ----------------------- |
| 001              | Rojo, Azul              | S, M, L                 |
| 002              | Verde, Blanco           | M, L, XL                |

#### **Problema:**

* **`Colores Disponibles`** y **`TamaÃ±os Disponibles`** son dos grupos de datos **independientes**, pero estÃ¡n en la misma tabla. Esta es una **dependencia multivaluada** que **no cumple con la 4FN**.

#### **SoluciÃ³n en 4FN:**

Creamos dos tablas separadas: una para **colores** y otra para **tamaÃ±os**:

1. **Tabla de Productos**:

   | **ID\_Producto** |
   | ---------------- |
   | 001              |
   | 002              |

2. **Tabla de Colores**:

   | **ID\_Producto** | **Color** |
   | ---------------- | --------- |
   | 001              | Rojo      |
   | 001              | Azul      |
   | 002              | Verde     |
   | 002              | Blanco    |

3. **Tabla de TamaÃ±os**:

   | **ID\_Producto** | **TamaÃ±o** |
   | ---------------- | ---------- |
   | 001              | S          |
   | 001              | M          |
   | 001              | L          |
   | 002              | M          |
   | 002              | L          |
   | 002              | XL         |

---

#### **Â¿QuÃ© conseguimos?** ğŸ†

* **Eliminamos dependencias multivaluadas**: Ahora, los colores y tamaÃ±os estÃ¡n en sus propias tablas, cada uno con una clave forÃ¡nea **`ID_Producto`** para hacer la relaciÃ³n.
* **Mejoramos la estructura**: Los datos estÃ¡n mÃ¡s organizados y no hay columnas que contengan mÃºltiples valores no relacionados.

---

### **Resumen Completo ğŸ“šğŸ‰**

1. **Tercera Forma Normal (3FN)**:

   * Elimina las **dependencias transitivas**.
   * Las columnas deben depender **directamente** de la **clave primaria**, no de otras columnas no clave.
   * **Ejemplo**: Separar **direcciÃ³n** y **cÃ³digo postal** en diferentes tablas.

2. **Cuarta Forma Normal (4FN)**:

   * Elimina las **dependencias multivaluadas** (cuando una columna tiene mÃ¡s de un valor independiente).
   * **Ejemplo**: Separar **colores disponibles** y **tamaÃ±os disponibles** en tablas diferentes.

---





### **Motores de Almacenamiento en MySQL** ğŸ—ƒï¸

1. **InnoDB** âš™ï¸

   * **Transacciones ACID** âœ…
   * **Bloqueo a nivel de fila** ğŸ”’
   * **Alta disponibilidad** ğŸ’¾
   * **Rendimiento bueno en cargas mixtas** âš¡
   * **Ideal para aplicaciones transaccionales** ğŸ¦

2. **MyISAM** ğŸ—‚ï¸

   * **No soporta transacciones** âŒ
   * **Bloqueo a nivel de tabla** ğŸ›‘
   * **Excelente para lecturas rÃ¡pidas** âš¡
   * **Ideal para bases de datos de solo lectura** ğŸ“š

3. **NDB Cluster** ğŸ–§

   * **Escalabilidad horizontal** ğŸ“ˆ
   * **Almacenamiento en memoria** âš¡
   * **Alta disponibilidad** ğŸ”„
   * **Ideal para aplicaciones en tiempo real** ğŸŒ

4. **HEAP (Memory)** ğŸ§ 

   * **Almacenamiento en RAM** ğŸƒ
   * **Muy rÃ¡pido** âš¡
   * **No persiste datos al reiniciar** âŒ
   * **Ideal para datos temporales o sesiones** ğŸ”„

5. **BDB (Berkeley DB)** ğŸ¢

   * **Transacciones ACID** âœ…
   * **Alta disponibilidad** ğŸ›¡ï¸
   * **Menos eficiente en consultas** ğŸ¢
   * **Ideal para sistemas con necesidad de transacciones** ğŸ¢

---

### **Resumen con Emojis** ğŸ¯

| **Motor**       | **Transacciones** | **Escalabilidad** | **Disponibilidad** | **Rendimiento** | **Uso Ideal**                         |
| --------------- | ----------------- | ----------------- | ------------------ | --------------- | ------------------------------------- |
| **InnoDB**      | âœ… ACID            | Media (vertical)  | Alta               | Bueno           | **Aplicaciones transaccionales** ğŸ¦   |
| **MyISAM**      | âŒ                 | Baja (vertical)   | Media              | Excelente       | **Bases de datos de solo lectura** ğŸ“š |
| **NDB Cluster** | âœ… ACID            | Alta (horizontal) | Alta               | Excelente       | **Aplicaciones en tiempo real** ğŸŒ    |
| **HEAP**        | âŒ                 | Baja (en memoria) | Baja               | Excelente       | **Datos temporales o de sesiÃ³n** ğŸ§    |
| **BDB**         | âœ… ACID            | Media (vertical)  | Alta               | Bajo            | **Sistemas con transacciones** ğŸ¢     |

---

### **Â¿CuÃ¡l Elegir?** ğŸ¤”

* **InnoDB**: Si necesitas **transacciones** y **alta disponibilidad**. ğŸ”
* **MyISAM**: Si necesitas **lecturas rÃ¡pidas** y tu base es **de solo lectura**. âš¡
* **NDB Cluster**: Si necesitas **escalabilidad horizontal** y **rendimiento en tiempo real**. ğŸŒ
* **HEAP**: Si necesitas **almacenamiento en memoria** para **datos temporales**. ğŸ§ 
* **BDB**: Si necesitas **transacciones** y **alta disponibilidad**. ğŸ¢

---


