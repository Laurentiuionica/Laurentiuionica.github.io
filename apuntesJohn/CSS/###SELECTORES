SELECTORES

---

### ğŸ§  Â¿QuÃ© son los *selectores*?

En programaciÃ³n web, especialmente en **CSS y JavaScript**, los *selectores* son como tus armas para apuntar a los elementos HTML. Literalmente le estÃ¡s diciendo al navegador:
"Â¡Eh tÃº! SÃ­, tÃº `#boton-rojo`, te voy a poner guapo o te voy a hacer explotar cuando te cliqueen" ğŸ’¥.

---

### ğŸ¨ Selectores en CSS (el estilista de tu web)

En CSS, los selectores te dejan decidir **quÃ© elementos se van a ver de quÃ© forma**. Puedes usarlos para cambiar colores, poner mÃ¡rgenes, animar cosas, y mÃ¡s. AquÃ­ van los tipos clave:

* Si escribes solo `p`, estÃ¡s eligiendo todos los pÃ¡rrafos.
* Si usas `.nombre`, estÃ¡s apuntando a todos los elementos con esa clase.
* Con `#identificador`, eliges un solo elemento especÃ­fico.
* TambiÃ©n puedes combinar cosas, como `div > p` (todos los pÃ¡rrafos hijos directos de un `div`).

Y si te pones creativo puedes usar pseudo-clases como `:hover` para cuando pasas el ratÃ³n, o `:nth-child(2)` para pillar el segundo de un grupo.

Esto te permite hacer efectos como: cuando pasas el ratÃ³n por una tarjeta, que se agrande y brille como si fuera una carta maldita de Jujutsu Kaisen ğŸ”®ğŸ”¥.

---

### ğŸ¤– Selectores en JavaScript (el cerebro del asunto)

En JS, los selectores son cÃ³mo **agarras un elemento del HTML** para hacerle algo: cambiarle el texto, ocultarlo, moverlo, hacerle caso a un clic...

* Si usas `getElementById("menu")`, estÃ¡s pillando un solo elemento con ese ID.
* Con `querySelector(".boton")` pillas el primer elemento con esa clase.
* Y con `querySelectorAll("input")` pillas todos los inputs que haya.

Luego, le metes funciones. Por ejemplo, cuando alguien hace clic en un botÃ³n, le puedes decir que muestre un mensaje, mande datos a un servidor, o que el botÃ³n se auto-destruya (con elegancia, claro âœ¨).

---

### ğŸ’¥ Lo guapo es combinarlos

Lo ideal es que uses los **selectores de CSS** para darle estilo a la web, y los **de JavaScript** para hacerla interactiva. Por ejemplo:

* En CSS le das color y efecto hover a un botÃ³n.
* En JS le dices que al hacer clic envÃ­e un formulario, cambie texto, o reproduzca un sonido de poder ğŸ”Š.

Todo empieza seleccionando el elemento correcto, bro. Si no lo seleccionas bien, el navegador no sabe a quiÃ©n te estÃ¡s dirigiendo. Es como gritarle a una pared.

---

### ğŸ§ª Truco de pro paâ€™ recordar

* Si es para varios elementos: usa clase `.algo`.
* Si es algo Ãºnico: usa ID `#algo`.
* Si quieres combinar estilos o comportamientos: mete `:hover`, `:focus`, `nth-child`, y cosas mÃ¡s loquitas.
* En JS, `querySelector` es tu pana para todo, mÃ¡s flexible que `getElementById`.

---

### ğŸ¬ Cierre con Kaisen Vibes

Los **selectores** son como maldiciones canalizadas ğŸ’€: si los usas bien, controlas completamente la energÃ­a de tu web. Si los usas mal, te cargas todo el diseÃ±o o el JS no encuentra lo que necesita.

AsÃ­ que ponte en modo hechicero supremo, y **elige bien a quiÃ©n estÃ¡s apuntando**. Porque ya sea para darle un estilo molÃ³n o hacer que reaccione con magia al clicâ€¦ todo empieza por saber **a quiÃ©n estÃ¡s eligiendo**.

Â¡Gojo estarÃ­a orgulloso de ti si clavas los selectores, bro! ğŸ¥·âœ¨

ğŸš¨ OJO BRO:
querySelector solo te devuelve el primer elemento que encuentra.

Si hay mÃ¡s de uno con la misma clase, y quieres todos, se usa querySelectorAll.


Tipos de selectores:

---

ğŸ”¹ **Selector de tipo** (tambiÃ©n llamado "de etiqueta o BLOQUE")
ğŸ‘‰ Este selecciona etiquetas HTML tal cual.
ğŸ“Œ Ejemplo: si escribes `p { color: red; }`, todos los `<p>` del HTML se ponen rojos.
ğŸ’¡ Ãštil cuando quieres afectar todos los elementos de un mismo tipo sin complicarte.

---

ğŸ”¸ **Selector de clase** (`.`)
ğŸ‘‰ Se usa cuando pones una clase en tu HTML, como `<div class="caja">`.
ğŸ“Œ En CSS harÃ­as `.caja { background: blue; }` y todos los que tengan esa clase pillan ese estilo.
ğŸ’ª Brutal para reutilizar estilos en varios sitios.

---

ğŸ”º **Selector de ID** (`#`)
ğŸ‘‰ Este apunta a un elemento con un `id`. Por ejemplo: `<h1 id="titulo">`.
ğŸ“Œ Lo atacas en CSS con `#titulo { font-size: 40px; }`.
âš ï¸ Solo debe haber uno con ese ID por pÃ¡gina, como un jefe supremo.

---

ğŸŒ¿ **Selector universal** (`*`)
ğŸ‘‰ Selecciona absolutamente todo.
ğŸ“Œ Ejemplo: `* { margin: 0; padding: 0; }` para resetear todos los mÃ¡rgenes.
â˜ ï¸ Ãšsalo con cabeza, que si no se te va de madre.

---

ğŸ“ **Selectores de descendencia**
ğŸ‘‰ Son para pillar elementos dentro de otros. Ejemplo: `div p { color: green; }`.
ğŸ“Œ Eso hace que todos los `<p>` que estÃ©n dentro de un `<div>` se pongan verdes.
ğŸ¯ Preciso como un francotirador.

---

âš¡ **Selectores de atributos**
ğŸ‘‰ Permiten pillar elementos segÃºn sus atributos, como `[type="text"]`.
ğŸ“Œ Ejemplo: `input[type="text"] { border: 1px solid #000; }`.
ğŸ” Muy Ãºtiles para formularios y componentes dinÃ¡micos.

---

ğŸ© **Selectores combinados (locuras avanzadas)**
ğŸ‘‰ Cosas como `ul > li` (solo los hijos directos), `a:hover` (cuando pasas el ratÃ³n), o `div + p` (el pÃ¡rrafo que viene justo despuÃ©s de un div).
ğŸ§  AquÃ­ empieza la magia real del CSS, bro.

---

ğŸ§  **Â¿Por quÃ© son importantes?**
Porque sin ellos el CSS no sabe a quÃ© le estÃ¡s hablando. Es como intentar hablarle a una multitud sin decir el nombre de nadie. Son el puente entre tu HTML y tu diseÃ±o.

---

1. **Selector inline** (estilo escrito directamente en la etiqueta HTML con `style="..."`)
   ğŸ‘‰ Tiene la mÃ¡xima prioridad, machaca todo lo demÃ¡s.
   Ejemplo: `<p style="color: blue;">` va a ser azul aunque en CSS digas otra cosa.

---

2. **Selector ID (`#`)**
   ğŸ‘‰ SÃºper especÃ­fico, gana a clases y etiquetas.
   Ejemplo: `#menu { color: red; }` se aplica antes que `.menu { color: green; }`.

---

3. **Selector de clase (`.`), atributos (`[attr]`), y pseudo-clases (`:hover`)**
   ğŸ‘‰ AquÃ­ estÃ¡n las clases y combinados que no sean IDs.
   Ejemplo: `.btn { color: yellow; }` o `input[type="text"] { color: black; }`.

---

4. **Selector de tipo (etiquetas, ej: `p`, `div`) y pseudo-elementos (`::before`)**
   ğŸ‘‰ Menor prioridad, se usa para reglas mÃ¡s generales.

---

5. **Selector universal (`*`)**
   ğŸ‘‰ Casi nunca tiene mÃ¡s peso, estÃ¡ abajo en la escala.

---

**Bonus troll:** si metes `!important` en un estilo, ese estilo se come a todos, menos a los inline con `!important` tambiÃ©n. Es como usar cheat codes en un videojuego. Pero abusar de eso es de novato y lÃ­o asegurado.

---

**En resumen:**
Inline > ID > Clase/atributos/pseudo-clases > Tipo > Universal

---

PSEUDOCLASES

---

ğŸ§  **Â¿QuÃ© narices es una pseudoclase?**

Una pseudoclase es como decirle al CSS:
*"Ey, quiero que este estilo se aplique **solo cuando pase esto**..."*

No cambias el HTML, no metes clases, solo le dices al CSS: **vigila esto y actÃºa**. Se usa con `:` y va pegada al selector.

---

ğŸ¯ **Algunas pseudoclases clave que sÃ­ o sÃ­ debes controlar:**

---

ğŸ”¸ `:hover`
Cuando pasas el ratÃ³n por encima de algo.
Ejemplo mental: pasas el puntero sobre un botÃ³n y cambia de color.
ğŸ‘‰ Muy usada en menÃºs, botones, links. BÃ¡sica y sexy.

---

ğŸ”¸ `:active`
Cuando haces clic, justo en el momento que estÃ¡s apretando.
Ejemplo: el botÃ³n se oscurece cuando lo presionas.
ğŸ‘‰ Ãštil para dar feedback visual al usuario.

---

ğŸ”¸ `:focus`
Cuando un input estÃ¡ seleccionado.
Ejemplo: haces clic en un campo de texto y se ilumina la caja.
ğŸ‘‰ Ideal para formularios accesibles y modernos.

---

ğŸ”¸ `:first-child`
Solo se aplica al **primer hijo** dentro de un padre.
Ejemplo: en una lista, que el primer elemento estÃ© en negrita.
ğŸ‘‰ Es como decir: "solo al primero, el resto que se aguanten".

---

ğŸ”¸ `:last-child`
Lo mismo que el anterior, pero para el Ãºltimo.
ğŸ‘‰ Para cerrar secciones, poner bordes, mÃ¡rgenes, lo que quieras.

---

ğŸ”¸ `:nth-child(n)`
Apunta al hijo nÃºmero **n**.
Puedes hacer virguerÃ­as como:

* `odd` (impares)
* `even` (pares)
* `3` (el tercero, sin excusas)

ğŸ‘‰ Esto lo usas para rayado de tablas, efectos escalonados, o destacar un Ã­tem puntual.

---

ğŸ”¸ `:not()`
Esta es la pseudoclase troll.
Te permite **negar** cosas.
Ejemplo mental: "pon todo en gris... excepto este".
ğŸ‘‰ Ultra Ãºtil para aplicar estilos por descarte.

---

ğŸ”¸ `:checked`
Cuando una checkbox o radio estÃ¡ marcada.
Ejemplo: marcas una opciÃ³n y cambia su aspecto.
ğŸ‘‰ Brutal para toggles, switches y formularios sin una sola lÃ­nea de JavaScript.

---

ğŸ”¸ `:disabled` / `:enabled`
Para inputs o botones desactivados/activados.
Te permite cambiar cÃ³mo se ven cuando no estÃ¡n disponibles.
ğŸ‘‰ Ideal para cuando tienes que forzar al usuario a completar algo antes de continuar.

---

ğŸ”¥ **Resumen callejero:**
Las pseudoclases son como sensores. CSS te dice:
*"Cuando esto pase, yo actÃºo."*
Y tÃº, como jefe de estilo, le dices exactamente cÃ³mo. No necesitas JS, ni cambiar el HTML, ni movidas raras. Solo CSS listo para el combate.


---

### Pseudoelementos CSS: Los cracks invisibles que mejoran tu web ğŸ‘»âœ¨

Los pseudoelementos son como pequeÃ±as capas extra que CSS pone dentro o alrededor de un elemento HTML para aÃ±adir contenido o decoraciÃ³n sin que tengas que meter mÃ¡s etiquetas en tu cÃ³digo. Esto hace que puedas darle un toque pro a tu web sin complicarte la vida ni ensuciar el HTML.

---

### Los reyes de los pseudoelementos ğŸ‘‘

**::before**
Inserta contenido justo **antes** del contenido original del elemento.
Ejemplo: si quieres que cada pÃ¡rrafo empiece con un fuego, haces esto:
p::before {
Â  content: "ğŸ”¥ ";
}
AsÃ­ todos tus pÃ¡rrafos empiezan con ese emoji que llama la atenciÃ³n y da flow.

**::after**
Inserta contenido justo **despuÃ©s** del contenido original.
Ejemplo: si quieres que cada pÃ¡rrafo termine con un check para dar sensaciÃ³n de â€œtodo correctoâ€, pones:
p::after {
Â  content: " âœ…";
}
AsÃ­ tus textos quedan con un toque final chulo y profesional.

---

### Â¿QuÃ© mÃ¡s puedes hacer con pseudoelementos? ğŸ› ï¸

* AÃ±adir iconos o sÃ­mbolos decorativos sin tocar el HTML.
* Crear barras, lÃ­neas o formas para decorar tÃ­tulos o secciones.
* Meter efectos visuales como sombras, degradados o animaciones.
* Mejorar la usabilidad con etiquetas o avisos extras sin meter mÃ¡s cÃ³digo.

---

### La regla de oro para que funcionen âš ï¸

Tienes que usar siempre la propiedad content. Si no la pones, los pseudoelementos no aparecen ni con un caÃ±Ã³n. Puede ser texto, emoji, o incluso vacÃ­o (content: "";) si solo quieres una forma o color.

---

### Un ejemplo guapo que suele molar ğŸ”¥

Quieres poner una barra roja a la izquierda de todos los tÃ­tulos h2, pero sin aÃ±adir mÃ¡s etiquetas en el HTML. Pues haces esto:

h2::before {
Â  content: "";
Â  display: inline-block;
Â  width: 5px;
Â  height: 100%;
Â  background-color: red;
Â  margin-right: 10px;
Â  vertical-align: middle;
}

AsÃ­ sin tocar el HTML, tus tÃ­tulos tienen una barra roja que da caÃ±a visualmente.

---

### Otros pseudoelementos menos comunes, pero Ãºtiles

* \::first-letter â†’ para darle estilo solo a la primera letra de un texto (como en libros antiguos).
* \::first-line â†’ para cambiar el estilo solo a la primera lÃ­nea.
* \::selection â†’ para cambiar el color cuando seleccionas texto con el ratÃ³n (pinta el texto seleccionado).

---

### En resumen, bro

Los pseudoelementos son la forma mÃ¡s limpia, elegante y profesional de aÃ±adir contenido extra o detalles visuales sin tocar ni un solo HTML. Son fÃ¡ciles de usar, sÃºper potentes y te permiten hacer diseÃ±os muy guapos con poco cÃ³digo.

No todas las propiedades de CSS son heredables. inherit se usa para forzar la herencia de aquellas propiedades que no sean heredables.
Cuando varias reglas afectan al mismo elemento se aplican una serie de normas de prioridad, la regla mas especifica prevalece. Por defecto las reglas definidas en una hoja de estilo de autor tienen preferencia (!important;) sobre las de usuario y estas a su vez sobre las del navegador. Para alterar este orden es posible marcar las declaraciones de las reglas de estilo como importantes.

Orden de prioridad:
-NAVEGADOR, USUARIO, AUTOR en IMPORTANT. AUTOR,USUARIO, NAVEGADOR en NORMAL
Dentro de las hojas de estilo de autor, las reglas en linea tienen prioridad sobre las hojas de estilo internas y estas a su vez sobre las externas. Si tras aplicar todos lo criterios dos reglas tienen la misma prioridad, se aplica la ultima de declararse.

Modelo de Cajas:
Define como se muestran los elementos en la pantalla, cada elemento HTML se representa dentro de una caja. El aspecto basico de una caja se define por su anchura, altura, relleno, borde y margen. Widh y height son ancho y alto de la caja.
El relleno (padding) es el espacio que va desde el contenido hasta el borde de la caja, con el mismo fondo que la caja.
El borde rodea la caja y el relleno y es posible cambiar tamaÃ±o, color y estilo y que ademas se distingue entre los cuatro lados. 
El margen es el espacio que deja la caja.


---

En HTML, los elementos se dividen en dos tipos segÃºn cÃ³mo se comportan en la pÃ¡gina: **elementos de bloque** y **elementos en lÃ­nea (inline)**. Esto define cÃ³mo se muestran, cÃ³mo ocupan espacio y quÃ© estilos puedes meterles. Vamos a darle con emojis y flow para que lo pilles a la primera.

---

### Elementos de bloque ğŸ§±â¬›ï¸

Estos elementos son como bloques grandes y fuertes que ocupan toda la lÃ­nea horizontal disponible, como un muro sÃ³lido. Siempre empiezan en una lÃ­nea nueva y empujan todo lo que venga despuÃ©s para abajo. Pueden tener ancho, alto, mÃ¡rgenes y relleno sin problema.

**Ejemplos tÃ­picos:**
`<div>`, `<p>`, `<h1>`, `<section>`, `<article>`, `<form>`

**Â¿CÃ³mo funcionan?**
Imagina un ladrillo ğŸ§± que ocupa todo el ancho de la pared. Cada ladrillo va debajo del anterior, sin juntarse en la misma fila.

**Visualmente:**
ğŸ§±
ğŸ§±
ğŸ§±

O sea, bloque tras bloque, uno bajo otro.

---

### Elementos en lÃ­nea (inline) âœ‚ï¸ğŸ“

Estos son los elementos pequeÃ±os que se comportan como letras o palabras en una frase. No empiezan en lÃ­nea nueva, ocupan solo el espacio que necesitan, y se colocan uno al lado del otro.

No puedes ponerles ancho o alto directo, ni margen arriba y abajo (solo a los lados).

**Ejemplos tÃ­picos:**
`<span>`, `<a>`, `<strong>`, `<em>`, `<img>`

**Â¿CÃ³mo funcionan?**
Piensa en letras o emojis en un texto, que fluyen en la misma lÃ­nea sin saltar. AsÃ­: ğŸ˜ğŸ‘ŠğŸ”¥

**Visualmente:**
ğŸ“ğŸ“ğŸ“ğŸ“ğŸ“ (todo seguido, sin romper lÃ­nea)

---

### Â¿Por quÃ© importa esta diferencia? ğŸ¤”

Porque si quieres controlar el diseÃ±o de tu web, necesitas saber quÃ© tipo de elemento tienes para aplicar bien estilos como mÃ¡rgenes, rellenos, o anchos.

* Si usas un elemento de bloque, puedes poner mÃ¡rgenes arriba, abajo, y ajustar su tamaÃ±o a lo bestia.
* Si usas un inline, solo puedes tocar margen a los lados y no va a empezar en una lÃ­nea nueva, sigue pegado a lo que tiene al lado.

---

### Elementos inline-block âš¡âœ¨

Son una mezcla rara pero muy Ãºtil: se comportan como inline (van en la misma lÃ­nea) pero admiten ancho, alto, mÃ¡rgenes y relleno como los bloques.

Ejemplo:
Un `<button>` normalmente es inline-block, o si a un `<span>` le pones `display: inline-block;` en CSS.

**Visualmente:**
Es como tener cajas pequeÃ±as (bloques) que estÃ¡n una al lado de otra, pero puedes controlarlas como si fueran bloques.

---

### Para cerrar, bro:

* ğŸ§± **Bloque:** ocupa toda la lÃ­nea, empieza en lÃ­nea nueva, margen arriba y abajo.
* âœ‚ï¸ **Inline:** ocupa solo lo que necesita, va pegado en lÃ­nea, margen solo a los lados.
* âš¡ **Inline-block:** inline que se puede controlar como bloque.

---



### `display: none;` âŒğŸ‘»

Este es el botÃ³n mÃ¡gico para **hacer que un elemento desaparezca por completo** de la pÃ¡gina. O sea, el elemento NO se ve, **no ocupa espacio ni lugar** en el diseÃ±o, como si ni existiera.

---

### Â¿QuÃ© pasa cuando usas `display: none;`?

* El elemento se **esconde totalmente**: ni se ve, ni deja hueco, ni afecta a los demÃ¡s.
* Es diferente de `visibility: hidden;` que solo lo hace invisible pero sigue ocupando espacio (como un fantasma).
* Tampoco responde a eventos ni se puede seleccionar porque no estÃ¡ en el flujo del documento.

---

### Â¿Para quÃ© sirve? ğŸ¯

* Para esconder menÃºs, pop-ups, o elementos que quieres mostrar despuÃ©s con JS (por ejemplo, un modal o un menÃº desplegable).
* Para ocultar cosas en mÃ³viles o pantallas pequeÃ±as y mostrarlas en grandes con media queries.
* Para hacer animaciones con JS cambiando el `display` y luego aplicando estilos.

---

### Ejemplo sencillo ğŸ‘‡

Si tienes un `<div>` que no quieres que se vea:

```css
div {
  display: none;
}
```

Â¡Pum! desaparece como por arte de magia.

---

### Resumen con emojis

`display: none;` = ğŸš«ğŸ‘€ + ğŸ•³ï¸ (no se ve y no ocupa espacio)

`visibility: hidden;` = ğŸ‘» (invisible pero sigue ahÃ­)

---


### CÃ³mo hacer un cÃ­rculo en un div ğŸ”µâšªï¸

Lo bÃ¡sico es usar CSS para que el div tenga el mismo ancho y alto, y luego redondear las esquinas al mÃ¡ximo con `border-radius`.

---

### Paso a paso:

1. Dale un tamaÃ±o fijo, por ejemplo 100px de ancho y alto (puedes cambiarlo a lo que quieras).
2. Usa `border-radius: 50%;` para que las esquinas se redondeen hasta formar un cÃ­rculo perfecto.
3. Ponle un color de fondo para verlo bien.

---

### CÃ³digo ejemplo directo:

```css
div {
  width: 100px;        /* ancho */
  height: 100px;       /* alto */
  background-color: #3498db;  /* color azul molÃ³n */
  border-radius: 50%;  /* Â¡esto lo convierte en cÃ­rculo! */
}

---

### Â¿QuÃ© estÃ¡ pasando? ğŸ¤“

* `width` y `height` igualitos hacen un cuadrado.
* `border-radius: 50%` redondea cada esquina la mitad del tamaÃ±o, creando un cÃ­rculo perfecto.
* El `background-color` es solo para que lo veas, puede ser el color que quieras o una imagen de fondo.

---

### Bonus ğŸ‘Œ

Si quieres un cÃ­rculo con borde, solo aÃ±ade:
`border: 3px solid #2c3e50;`

Si quieres que sea un cÃ­rculo responsive que se adapte al tamaÃ±o del contenedor, puedes usar porcentajes o unidades relativas, pero para empezar asÃ­ estÃ¡ de lujo.



---

### Sombras en CSS: el poder del `box-shadow` y `text-shadow` ğŸ•¶ï¸âœ¨

---

### 1. `box-shadow` â€” Sombras para cajas y elementos ğŸ ğŸ–¤

Este es el mÃ¡s usado, para crear sombras alrededor de cualquier caja, div, botÃ³n, imagen, lo que sea.

---

### Sintaxis bÃ¡sica:

```css
box-shadow: offsetX offsetY blurRadius spreadRadius color;
```

* **offsetX** â†’ cuÃ¡nto se mueve la sombra a la derecha (+) o a la izquierda (-)
* **offsetY** â†’ cuÃ¡nto se mueve la sombra hacia abajo (+) o arriba (-)
* **blurRadius** â†’ cuÃ¡nto se difumina la sombra (mÃ¡s valor = sombra mÃ¡s suave y grande)
* **spreadRadius** â†’ cuÃ¡nto crece o se reduce la sombra (positivo la hace mÃ¡s grande, negativo mÃ¡s pequeÃ±a)
* **color** â†’ color de la sombra (puede tener transparencia con rgba)

---

### Ejemplo bÃ¡sico y guapo:

```css
div {
  box-shadow: 5px 5px 10px rgba(0,0,0,0.5);
}
```

Esto hace una sombra que se mueve 5 pÃ­xeles a la derecha y 5 hacia abajo, con un desenfoque suave de 10 pÃ­xeles y color negro semitransparente.

---

### Extra: mÃºltiples sombras

Puedes poner varias sombras separadas por coma:

```css
box-shadow: 3px 3px 5px rgba(0,0,0,0.3), -3px -3px 5px rgba(255,255,255,0.2);
```

O sea, una sombra oscura abajo a la derecha y una clarita arriba a la izquierda para efecto â€œliftingâ€.

---

### Sombras internas ğŸ•³ï¸ğŸ”¦

Si quieres que la sombra estÃ© dentro del elemento (como un recorte o hundimiento), usa la palabra clave `inset`:

```css
box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
```

Esto mete la sombra hacia dentro, da efecto de relieve hundido o borde sombreado.

---

### 2. `text-shadow` â€” Sombras para texto âœï¸ğŸ–¤

Si quieres que el texto tenga sombra para destacar, usarÃ¡s `text-shadow` con casi la misma sintaxis (sin spread):

```css
text-shadow: offsetX offsetY blurRadius color;
```

Ejemplo:

```css
h1 {
  text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
}
```

Esto hace que el texto tenga una sombra negra suave, desplazada 2 pÃ­xeles a la derecha y abajo.

---

### Tips para usar sombras como un pro ğŸ’¡

* Las sombras no deben ser muy exageradas para que no cansen la vista.
* Usa transparencias para que la sombra sea sutil y elegante.
* Combina sombras internas y externas para efectos cool.
* Las sombras pueden dar profundidad sin necesidad de imÃ¡genes ni efectos complejos.

---

### Resumen con emojis

* `box-shadow` = ğŸ â¡ï¸ğŸ’¨ sombra de caja, con offsetX/Y, desenfoque, expansiÃ³n y color.
* `box-shadow inset` = ğŸ•³ï¸ sombra dentro de la caja, efecto hundido.
* `text-shadow` = âœï¸ğŸ–¤ sombra para texto, con offset y blur.



---

### Posicionamiento en CSS: controlar dÃ³nde estÃ¡ tu elemento ğŸ§­ğŸ“

El posicionamiento sirve para mover y colocar elementos en la pÃ¡gina de formas especÃ­ficas, mÃ¡s allÃ¡ del flujo normal del HTML.

---

### Tipos bÃ¡sicos de posicionamiento:

---

### 1. `static` ğŸ  (por defecto)

Es la posiciÃ³n natural, sin mover nada. El elemento se coloca segÃºn el flujo normal del documento.

**No se puede mover con top, left, right, bottom.**

---

### 2. `relative` ğŸ¯

El elemento se posiciona relativo a su posiciÃ³n normal, permite desplazar a los elementos en relacion a la posicion que tendrian en el modo estatico. Los demas elementos ignoran este desplazamiento y se posicionan como si el elemento estuviera en la posicion normal, asi que se pueden producir solapamientos
.
Puedes usar `top`, `left`, `right`, `bottom` para moverlo pero el espacio que ocupa en el flujo sigue ahÃ­ (como un fantasma).

Ejemplo:

```css
div {
  position: relative;
  top: 10px;   /* baja 10 pÃ­xeles desde su posiciÃ³n normal */
  left: 5px;   /* se mueve 5 pÃ­xeles a la derecha */
}
```

---

### 3. `absolute` ğŸš€

El elemento se posiciona respecto a su antecesor **posicionado** mÃ¡s cercano (que tenga `position: relative`, `absolute`, `fixed` o `sticky`).

Sale del flujo normal, o sea que no ocupa espacio y puede superponerse.

Ejemplo:

```css
.container {
  position: relative;
}
.child {
  position: absolute;
  top: 20px;
  right: 15px;
}
```

AquÃ­ `.child` se coloca 20px desde arriba y 15px desde la derecha del `.container`.

---

### 4. `fixed` ğŸ“Œ

El elemento se posiciona respecto a la ventana del navegador, o sea que no se mueve aunque hagas scroll.

Muy usado para menÃºs fijos o botones flotantes.

Ejemplo:

```css
nav {
  position: fixed;
  top: 0;
  width: 100%;
}
```

---

### 5. `sticky` ğŸ§²

Es como un mix entre `relative` y `fixed`.

El elemento se comporta como `relative` hasta que llegas a un punto del scroll, y ahÃ­ se queda â€œpegadoâ€ fijo.

Ejemplo:

```css
header {
  position: sticky;
  top: 0;
  background: white;
}
```

Esto hace que el header se quede fijo en la parte superior cuando haces scroll.

---

### Propiedades que se usan con posicionamiento:

* `top`: distancia desde arriba
* `right`: distancia desde la derecha
* `bottom`: distancia desde abajo
* `left`: distancia desde la izquierda

Se usan para mover el elemento segÃºn el tipo de posiciÃ³n.

---

### Resumen con emojis:

* `static` = ğŸ  posiciÃ³n normal, sin mover.
* `relative` = ğŸ¯ mueve respecto a su sitio original (pero espacio sigue).
* `absolute` = ğŸš€ mueve respecto al padre posicionado, fuera del flujo.
* `fixed` = ğŸ“Œ fijo en pantalla, no se mueve con scroll.
* `sticky` = ğŸ§² pega y se queda fijo cuando llegas a un punto.


---

### Float no es posicionamiento, es â€œflotarâ€ elementos ğŸ›ŸğŸŒŠ

Mientras que los modos de posicionamiento (`static`, `relative`, `absolute`, `fixed`, `sticky`) controlan cÃ³mo se coloca un elemento en el espacio, **float** sirve para hacer que un elemento se â€œpegueâ€ a la izquierda o derecha y que el contenido que venga despuÃ©s fluya a su alrededor, como texto al lado de una imagen.

---

### Por quÃ© float no es posicionamiento:

* No saca al elemento del flujo completamente (aunque puede hacer que el contenedor â€œcolapseâ€ si no tienes cuidado).
* No se controla con `top`, `left`, etc. sino con `float: left` o `float: right`.
* Es mÃ¡s una tÃ©cnica para envolver contenido que para colocar elementos en un punto exacto.

---

### Resumen brutal:

* **Modos de posicionamiento** = controlan la posiciÃ³n absoluta o relativa en la pÃ¡gina.
* **Float** = mueve el elemento a un lado y hace que el contenido lo rodee.

---

Hoy en dÃ­a, para layouts mÃ¡s chulos y fÃ¡ciles, mejor usa Flexbox o Grid que te dan control total sin liarla con floats, pero sigue siendo Ãºtil para cosas simples como imÃ¡genes que quieres que floten al lado.


Modos de posicionamiento:

ğŸ”¥ SOLAPAMIENTOS
---

ğŸ§  **Â¿QuÃ© significa el valor de `z-index`?**
Cuanto **mayor es el valor**, **mÃ¡s arriba** se coloca el elemento en la pila de capas. Es como un montÃ³n de cartas:

* `z-index: 1` estÃ¡ por encima de `z-index: 0`.
* `z-index: 9999` aplasta a todos los demÃ¡s como un jefe final ğŸ¥µ.

---

ğŸ“Œ **Pero ojo**: `z-index` **solo funciona en elementos posicionados**, es decir, con `position: relative`, `absolute`, `fixed` o `sticky`. Si no tienen eso, `z-index` se lo pasa por el forro.

---

### Resumen con flow:

* `z-index` = orden de capas.
* Valor mÃ¡s alto = **mayor prioridad visual**, se ve por encima.
* Necesita que el elemento estÃ© posicionado (`relative`, `absolute`, etc.).
* Puede ser negativo (`z-index: -1`) para mandar algo al fondo.

---

Con el modo absoluto se especifica la posicion del elemento en relacion a otro elemento. Los demas elementos se posicionan como si los elementos con posicionamiento absoluto no existieran, asi que pueden darse solapamientos.
El posicionamiento fijo sirve para dejar un elemento fijo en la pantalla, aunque haya desplazamiento vertical u horizontal..

El mÃ³dulo de caja flexible se cono como flexbox. diseÃ±ado como un modelo unidimensional de layout y como un metodo para ayudar a distribuir el espacio entre los items de una interfaz y mejorar las capacidades de alineacion. Flexbox es unidimensional pero destaca que maneja el layout en una sola dimension a la vez 
El posicionamiento fijo sirve para dejar un elemento fijo en la pantalla, aunque haya desplazamiento vertical u horizontal.

Lo que se usa mas que el float es el GRID.
Grid-Layout es el como se construye la estructura de un sitio web, se crea mediante filas y columnas y con gran control de diseÃ±o para decidir donde meter el contenido. Vamos a poder crear sitios totalmente responsive y facilitando el uso de @media.
Con Grid vamos a tener un elemento que sera el contenedor principal (body). Dentro del contenedor tendremos la estructura tal y como lo hemos visto en HTML5
En nuestro CSS lo primero que tenemos que hacer es trabajar el estilo del contenedor. Para poder trabajar con grid el display de este elemento sera grid.
Podemos espaciar la regila de nuestras filas y columnas mediantee la propiedad gap. Su valor sera una unidad de medida valida (en px).
Para definir el numero de columnas usaremos la medida de fraccion de CSS (fr)
En grid la definicion de las columnas se realiza mediante propiedad grid-template-columns y su valor sera las fracciones que ocupa cada columna(podemos usar la funcion repeat(n,fr)si son muchas columnas).
Para definir las filas en grid usaremos la propiedad grid-template-rows y su valor puede ser en (fr) aunque normalmente se puede dejar en auto ya que crecen segun el contenido. En realidad esta definicion no se utiliza si usamos la definicion implicita de las filas usando grid-template-areas en la que le diremos el mapa del contenido de cada celda en nuestro grid.

Las media queries permiten adaptar la presentacion de la pagina a las caracteristicas del dispositivo con que se accede a la pagina.
Constituyen la base para conseguir un diseÃ±o adaptable. Entre otras cosas con las media queries podemos preguntar por:
-Tipo de dispositivo
-Orientacion de la pantalla.
-Ancho de la ventana del navegador.
El media query ex una expresion logica que se evalua a verdadero o falso. Cuando sale verdadero, las reglas asociadas a la consultan entran en vigor y al ser falso no se tienen en cuenta.
